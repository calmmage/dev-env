# ------------------------------------------------------------------------------
# verified

# make sure the dev-env location is available
[ -f ~/.dev-env-location ] && source ~/.dev-env-location

# Add warning if DEV_ENV_PATH is not set
if [ -z "$DEV_ENV_PATH" ]; then
    echo "Warning: DEV_ENV_PATH is not set. Please run dev-env/bootstrap.sh to configure it."
fi

# Function to explain how to add a new tool alias
add_tool() {
    echo "Instructions for adding a new tool alias:"
    echo "1. Make sure DEV_ENV_PATH is set correctly at ~/.dev-env-location"
    echo "2. Add your tool script to dev_env repo in tools/"
    echo "3. Add an alias to dev_env/nix/modules/home-manager/dotfiles/zshrc in one of these formats:"
    echo "   - For direct Python scripts:"
    echo "     alias toolname=\"$DEV_ENV_PATH/.venv/bin/python \$DEV_ENV_PATH/tools/your_tool.py\""
    echo "   - For Typer CLI tools:" 
    echo "     alias toolname=\"\$DEV_ENV_PATH/.venv/bin/typer \$DEV_ENV_PATH/tools/your_tool/your_tool.py\""
    echo "4. nix-shell -p zsh"
    echo "5. source ~/.zshrc (or restart your terminal)"
}


# ------------------------------------------------------------------------------
#
#
#
#
#
#
#
#
#
#
#
#
#
# ------------------------------------------------------------------------------
# unverified


export HELP="This is a help message by Petr Lavrov, on Jan 2024

calmlib aliases:
np, new_project, pm, project_manager
cdl, cds, cdp - cd to latest, structured and playground
cd1, 2, 3 - same
# todo: construct this help message dynamically in calmmage_dev_env
cdr, lsr, cdf - fuzzy match cd and ls

personal aliases:
hetzner - ssh to hetzner server

fp - find project (find dir / file name in ~/work)
find_ \$text \$path - find text in file (grep all text instances in dir)
mva - move the dir to new location and leave a symlink instead

pro cli libs:
ghc / gh copilot - github copilot cli
aie - gh copilot explain
ais - gh copilot suggest

tree
awk, grep

todo: add a personal, code-aware ai helper with vector store
quick: simple vector store code snippet search
aliases: import a code chunk / notebook / dir
more: knowledge base, similar.
"




# find_what_where() {
#     grep -rnw "$2" -e "$1"
# }




# cdf prj -> cd if is_substring(prj, dir). Fails on multi-match; See also: cdf
change_dir_fuzzy() {
    # Python script handling all logic including match count
    python_code="from pathlib import Path
# from calmlib.utils.common import is_subsequence

def is_subsequence(sub: str, main: str):
    sub_index = 0
    main_index = 0
    while sub_index < len(sub) and main_index < len(main):
        if sub[sub_index] == main[main_index]:
            sub_index += 1
        main_index += 1
    return sub_index == len(sub)

subsequence = '$1'
base_path = Path('.')
matching_dirs = [entry.name for entry in base_path.iterdir() if entry.is_dir() and is_subsequence(subsequence, entry.name)]

if len(matching_dirs) == 1:
    print(matching_dirs[0])
elif len(matching_dirs) > 1:
    x = ', '.join(matching_dirs)
    raise ValueError(f'Too many matches: {x}')
else:
    raise ValueError('No matches found')"

    # Execute the complete Python script and handle exceptions
    local match=$(python -c "$python_code")

    if [ -n "$match" ]; then
        # Only one match, change directory
        cd "$match"
    fi
}
# lsr abc -> ls *a*b*c*
list_dir_regexp() {
    dir_regexp=$(python -c "print('*'+'*'.join('$1')+'*')")
    eval "ls $dir_regexp"
}

# cdr prj -> cd *p*r*j*; See also: cdf
change_dir_regexp() {
    # Execute the Python script and store the result
    dir_regexp=$(python -c "print('*'+'*'.join('$1')+'*')")
    eval "ls -d $dir_regexp"
    # echo $dir_regexp
    # dir_names=$(echo ($dir_regexp))
    # echo $dir_names
    # ls ($dir_regexp)
    eval "cd $dir_regexp 2>/dev/null"
}


# requires export DEV_ENV_PATH="/path/to/poetry/env"
# default - DEV_ENV_PATH="$HOME/.calmmage/dev_env/.venv"
# export PROJECTS_ROOT="$HOME/work/projects"

run_with_poetry() {
    # Check if the environment variable is set
    if [ -z "$DEV_ENV_PATH" ]; then
        echo "Error: DEV_ENV_PATH must be set"
        return 1
    fi

    # Check if a script path is provided as an argument
    if [ $# -eq 0 ]; then
        echo "Error: No script path provided"
        echo "Usage: run_with_poetry <script_path> [args...]"
        return 1
    fi

    # Get the script path (first argument)
    local SCRIPT_PATH="$1"
    shift  # Remove the first argument, leaving any additional args

    # Check if the script exists
    if [ ! -f "$SCRIPT_PATH" ]; then
        echo "Error: Script not found at $SCRIPT_PATH"
        return 1
    fi

    # Activate the Poetry environment, run the script with any additional args, and deactivate
    (
        source "$DEV_ENV_PATH/bin/activate" && \
        python "$SCRIPT_PATH" "$@" && \
        deactivate
    )
}
